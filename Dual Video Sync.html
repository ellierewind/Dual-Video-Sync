<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dual Video Player with Sync</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .main-player-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        .video-player {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .video-element {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* Transform origin so rotations/scale center nicely */
        #video1 {
            transform-origin: center center;
            will-change: transform;
        }

        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .video-player:hover .controls {
            transform: translateY(0);
        }

        .progress-container {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            margin-bottom: 15px;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: #ff0000;
            border-radius: 3px;
            width: 0%;
            position: relative;
        }

        .progress-handle {
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .progress-container:hover .progress-handle {
            opacity: 1;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .time-display {
            font-size: 14px;
            min-width: 80px;
        }

        .speed-select {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        /* Ensure dropdown list items stay readable on white menus */
        .speed-select option {
            color: #000;
            background: #fff;
        }

        .file-input {
            display: none;
        }

        .file-label {
            background: #ff0000;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .file-label:hover {
            background: #cc0000;
        }

        /* Overlay Player */
        .overlay-player {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            height: 225px;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            /* Use custom corner handles instead of native resizer */
            resize: none;
            min-width: 200px;
            min-height: 112px;
        }

        /* Custom corner resize handles */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: transparent; /* invisible handle */
            border: none;            /* remove visible border */
            border-radius: 2px;
            z-index: 1002;
        }
        .resize-handle.nw { top: -1px; left: -1px; cursor: nwse-resize; }
        .resize-handle.ne { top: -1px; right: -1px; cursor: nesw-resize; }
        .resize-handle.sw { bottom: -1px; left: -1px; cursor: nesw-resize; }
        .resize-handle.se { bottom: -1px; right: -1px; cursor: nwse-resize; }



        .subtitle-display {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            max-width: 80%;
            line-height: 1.4;
            z-index: 100;
            display: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .overlay-subtitle-display {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            max-width: 90%;
            line-height: 1.2;
            z-index: 100;
            display: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .dragging {
            user-select: none;
        }

        .overlay-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .overlay-player:hover .overlay-controls {
            transform: translateY(0);
        }

        /* Idle state: hide cursor and controls after inactivity */
        body.idle {
            cursor: none;
        }
        body.idle .controls,
        body.idle .overlay-controls {
            transform: translateY(100%) !important;
        }
        /* When not idle, show both control bars */
        body:not(.idle) .controls,
        body:not(.idle) .overlay-controls {
            transform: translateY(0) !important;
        }

        .overlay-progress {
            width: 100%;
            height: 3px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            margin-bottom: 8px;
            cursor: pointer;
        }

        .overlay-progress-bar {
            height: 100%;
            background: #ff0000;
            border-radius: 2px;
            width: 0%;
        }

        .overlay-control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-size: 12px;
        }

        .overlay-btn {
            background: none;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            padding: 4px;
        }

        /* Sync Controls */
        .sync-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1001;
        }

        .sync-label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .sync-input {
            width: 80px;
            padding: 4px;
            border: 1px solid #555;
            background: #222;
            color: white;
            border-radius: 4px;
        }

        .sync-btn {
            background: #ff0000;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 12px;
        }

        .sync-btn:hover {
            background: #cc0000;
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            outline: none;
            border-radius: 2px;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* --- UI polish overrides (non-breaking) --- */
        :root {
            --accent: #ff2d55;
            --accent-2: #ff8a9e;
            --panel-bg: rgba(12,12,14,0.78);
            --panel-stroke: rgba(255,255,255,0.10);
            --text: #f5f5f7;
            --muted: rgba(255,255,255,0.7);
        }

        .controls {
            background: linear-gradient(transparent, var(--panel-bg));
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-top: 1px solid var(--panel-stroke);
            padding: 12px 16px 16px;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }

        .overlay-controls {
            background: var(--panel-bg);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border-top: 1px solid var(--panel-stroke);
            padding: 8px 10px 10px;
        }

        .progress-container {
            height: 8px;
            background: rgba(255,255,255,0.18);
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            border-radius: 6px;
        }

        .progress-handle {
            right: -7px;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border: 2px solid #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .overlay-progress {
            height: 6px;
            background: rgba(255,255,255,0.18);
            border-radius: 6px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .overlay-progress-bar {
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            border-radius: 6px;
        }

        .control-row {
            color: var(--text);
            gap: 12px;
        }
        .control-group { gap: 10px; }

        .control-btn, .overlay-btn {
            background: rgba(255,255,255,0.08);
            border: 1px solid var(--panel-stroke);
            color: var(--text);
            font-size: 16px;
            padding: 6px 10px;
            border-radius: 10px;
            transition: transform 0.1s ease, background 0.15s ease, border-color 0.15s ease;
            line-height: 1;
        }
        .overlay-btn { font-size: 14px; padding: 4px 8px; }
        .control-btn:hover, .overlay-btn:hover { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.22); }
        .control-btn:active, .overlay-btn:active { transform: scale(0.98); }

        .time-display { color: var(--muted); min-width: 84px; }

        .speed-select {
            background: rgba(255,255,255,0.08);
            border: 1px solid var(--panel-stroke);
            color: var(--text);
            padding: 6px 28px 6px 10px;
            border-radius: 10px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 14px;
        }

        .file-label {
            background: var(--accent);
            color: #fff;
            padding: 6px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.18);
            transition: filter 0.15s ease, transform 0.1s ease;
        }
        .file-label:hover { filter: brightness(1.03); }
        .file-label:active { transform: translateY(1px); }

        .overlay-player {
            border: 1px solid var(--panel-stroke);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

        .volume-container { gap: 6px; }
        .volume-slider { width: 100px; height: 4px; background: transparent; border-radius: 999px; -webkit-appearance: none; appearance: none; }
        /* Dynamic fill based on --vol (0%–100%) */
        .volume-slider::-webkit-slider-runnable-track { height: 4px; background: linear-gradient(90deg, var(--accent) 0 var(--vol, 100%), rgba(255,255,255,0.18) var(--vol, 100%) 100%); border-radius: 999px; }
        .volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -4px; width: 12px; height: 12px; background: #fff; border: 2px solid var(--accent); border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        .volume-slider::-moz-range-track { height: 4px; background: linear-gradient(90deg, var(--accent) 0 var(--vol, 100%), rgba(255,255,255,0.18) var(--vol, 100%) 100%); border-radius: 999px; }
        .volume-slider::-moz-range-thumb { width: 12px; height: 12px; background: #fff; border: 2px solid var(--accent); border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); }

        .subtitle-display { border-radius: 10px; font-size: 18px; padding: 8px 14px; }
        .overlay-subtitle-display { border-radius: 8px; }

        /* --- Alignment tweaks for overlay + sync panel --- */
        /* Override inline sizes for overlay elements to match main */
        #speedSelect2 { font-size: 13px !important; padding: 6px 28px 6px 10px !important; }
        #subtitleBtn2 { font-size: 13px !important; }
        #volumeSlider2 { width: 100px !important; height: 4px !important; }
        .overlay-controls .file-label { font-size: 13px !important; padding: 6px 12px !important; }
        .overlay-btn { font-size: 16px; padding: 6px 10px; }

        /* Sync panel theme match */
        .sync-controls {
            background: var(--panel-bg);
            border: 1px solid var(--panel-stroke);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        }
        .sync-input {
            border: 1px solid var(--panel-stroke);
            background: rgba(255,255,255,0.06);
            color: var(--text);
        }
        .sync-label { color: var(--muted); }
        .sync-btn {
            background: var(--accent);
            border: 1px solid rgba(255,255,255,0.18);
        }
        .sync-btn:hover { filter: brightness(1.03); }
    </style>
</head>
<body>
    <!-- Main Video Player -->
    <div class="main-player-container">
        <div class="video-player" id="mainPlayer">
            <video class="video-element" id="video1">
                <source src="" type="video/mp4">
            </video>
            <div class="subtitle-display" id="subtitle1Display"></div>
            <div class="controls">
                <div class="progress-container" id="progress1">
                    <div class="progress-bar" id="progressBar1">
                        <div class="progress-handle"></div>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <button class="control-btn" id="playBtn1">▶</button>
                        <div class="time-display" id="timeDisplay1">0:00 / 0:00</div>
                        <select class="speed-select" id="speedSelect1">
                            <option value="1">1x</option>
                            <option value="1.25">1.25x</option>
                            <option value="1.5">1.5x</option>
                            <option value="1.75">1.75x</option>
                            <option value="2">2x</option>
                        </select>
                        <div class="volume-container">
                            <button class="control-btn" id="muteBtn1">🔊</button>
                            <input type="range" class="volume-slider" id="volumeSlider1" min="0" max="1" step="0.1" value="1">
                        </div>
                        <button class="control-btn" id="subtitleBtn1" title="Toggle Subtitles">CC</button>
                    </div>
                    <div class="control-group">
                        <button class="control-btn" id="swapBtn" title="Swap Videos">🔄</button>
                        <label class="file-label" for="file1">Choose Video 1</label>
                        <input type="file" id="file1" class="file-input">
                        <label class="file-label" for="subtitle1">SRT 1</label>
                        <input type="file" id="subtitle1" class="file-input" accept=".srt">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Overlay Video Player -->
    <div class="overlay-player" id="overlayPlayer">
        <video class="video-element" id="video2" style="width: 100%; height: 100%;">
            <source src="" type="video/mp4">
        </video>
        <div class="overlay-subtitle-display" id="subtitle2Display"></div>
        <div class="overlay-controls">
            <div class="overlay-progress" id="progress2">
                <div class="overlay-progress-bar" id="progressBar2"></div>
            </div>
            <div class="overlay-control-row">
                <div class="control-group">
                    <button class="overlay-btn" id="playBtn2">▶</button>
                    <span class="time-display" id="timeDisplay2">0:00</span>
                    <select class="speed-select" id="speedSelect2" style="font-size: 10px; padding: 2px 4px;">
                        <option value="1">1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="1.75">1.75x</option>
                        <option value="2">2x</option>
                    </select>
                    <div class="volume-container">
                        <button class="overlay-btn" id="muteBtn2">🔊</button>
                        <input type="range" class="volume-slider" id="volumeSlider2" min="0" max="1" step="0.1" value="1" style="width: 60px; height: 3px;">
                    </div>
                    <button class="overlay-btn" id="subtitleBtn2" title="Toggle Subtitles" style="font-size: 10px;">CC</button>
                </div>
                <div style="display: flex; gap: 5px;">
                    <label class="file-label" for="file2" style="font-size: 10px; padding: 4px 8px;">Choose Video 2</label>
                    <label class="file-label" for="subtitle2" style="font-size: 10px; padding: 4px 8px;">SRT 2</label>
                </div>
                <input type="file" id="file2" class="file-input">
                <input type="file" id="subtitle2" class="file-input" accept=".srt">
            </div>
        </div>
        <!-- Corner resize handles -->
        <div class="resize-handle nw" data-handle="nw"></div>
        <div class="resize-handle ne" data-handle="ne"></div>
        <div class="resize-handle sw" data-handle="sw"></div>
        <div class="resize-handle se" data-handle="se"></div>
    </div>

    <!-- Sync Controls -->
    <div class="sync-controls" id="syncControls">
        <div class="sync-group">
            <button class="sync-btn" id="setSyncBtn">Set Sync Point</button>
        </div>
        
    </div>

    <script>
        // Global variables
        let video1 = document.getElementById('video1');
        let video2 = document.getElementById('video2');
        let syncPoint1 = null;
        let syncPoint2 = null;
        let isSynced = false;
        let delay = 0;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let isResizing = false;
        let resizeState = { startX: 0, startY: 0, startW: 0, startH: 0, startLeft: 0, startTop: 0, handle: '' };
        let subtitles1 = [];
        let subtitles2 = [];
        let subtitlesEnabled1 = false;
        let subtitlesEnabled2 = false;

        // ===== Transform state (MAIN PLAYER ONLY) =====
        const ZOOM_STEP = 0.05;
        const STRETCH_STEP = 0.05;
        const ROTATE_STEP = 1;      // degrees per tap (Alt+Numpad1/3)
        const MOVE_STEP = 20;       // px per tap (Ctrl+Numpad directions)
        const MIN_ZOOM = 0.05;
        const MAX_ZOOM = 10;
        const MIN_STRETCH = 0.1;
        const MAX_STRETCH = 10;

        let tf = {
            zoom: 1,
            stretchX: 1,
            stretchY: 1,
            flipX: 1,
            flipY: 1,
            rot: 0,        // degrees
            tx: 0,         // translate X (px)
            ty: 0          // translate Y (px)
        };

        function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

        function applyTransform(){
            const sx = tf.zoom * tf.stretchX * tf.flipX;
            const sy = tf.zoom * tf.stretchY * tf.flipY;
            video1.style.transform = `translate(${tf.tx}px, ${tf.ty}px) rotate(${tf.rot}deg) scale(${sx}, ${sy})`;
        }

        function resetTransforms(){
            tf = { zoom: 1, stretchX: 1, stretchY: 1, flipX: 1, flipY: 1, rot: 0, tx: 0, ty: 0 };
            applyTransform();
        }

        function recenter(){
            tf.tx = 0; tf.ty = 0; applyTransform();
        }

        // Initialize players
        function initializePlayers() {
            // File inputs
            document.getElementById('file1').addEventListener('change', (e) => loadVideo(e, video1));
            document.getElementById('file2').addEventListener('change', (e) => loadVideo(e, video2));
            
            // Subtitle inputs
            document.getElementById('subtitle1').addEventListener('change', (e) => loadSubtitle(e, 1));
            document.getElementById('subtitle2').addEventListener('change', (e) => loadSubtitle(e, 2));
            
            // Subtitle toggle buttons
            document.getElementById('subtitleBtn1').addEventListener('click', () => toggleSubtitles(1));
            document.getElementById('subtitleBtn2').addEventListener('click', () => toggleSubtitles(2));

            // Play/pause buttons
            document.getElementById('playBtn1').addEventListener('click', () => togglePlay(video1, 'playBtn1'));
            document.getElementById('playBtn2').addEventListener('click', () => togglePlay(video2, 'playBtn2'));

            // Progress bars
            document.getElementById('progress1').addEventListener('click', (e) => seekVideo(e, video1, 'progress1'));
            document.getElementById('progress2').addEventListener('click', (e) => seekVideo(e, video2, 'progress2'));

            // Speed controls
            document.getElementById('speedSelect1').addEventListener('change', (e) => changeSpeed(video1, e.target.value));
            document.getElementById('speedSelect2').addEventListener('change', (e) => changeSpeed(video2, e.target.value));

            // Volume controls
            document.getElementById('volumeSlider1').addEventListener('input', (e) => {
                changeVolume(video1, e.target.value, 'muteBtn1');
                const pct = Math.max(0, Math.min(1, parseFloat(e.target.value))) * 100;
                e.target.style.setProperty('--vol', pct + '%');
            });
            document.getElementById('volumeSlider2').addEventListener('input', (e) => {
                changeVolume(video2, e.target.value, 'muteBtn2');
                const pct = Math.max(0, Math.min(1, parseFloat(e.target.value))) * 100;
                e.target.style.setProperty('--vol', pct + '%');
            });
            document.getElementById('muteBtn1').addEventListener('click', () => toggleMute(video1, 'muteBtn1', 'volumeSlider1'));
            document.getElementById('muteBtn2').addEventListener('click', () => toggleMute(video2, 'muteBtn2', 'volumeSlider2'));

            // Initialize volume slider fills
            ['volumeSlider1','volumeSlider2'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    const pct = Math.max(0, Math.min(1, parseFloat(el.value))) * 100;
                    el.style.setProperty('--vol', pct + '%');
                }
            });

            // Swap button
            document.getElementById('swapBtn').addEventListener('click', swapVideos);

            // Sync control (Set only)
            document.getElementById('setSyncBtn').addEventListener('click', setSyncPoint);

            // Video events
            video1.addEventListener('timeupdate', () => {
                updateProgress(video1, 'progressBar1', 'timeDisplay1');
                updateSubtitles(1, video1.currentTime);
            });
            video2.addEventListener('timeupdate', () => {
                updateProgress(video2, 'progressBar2', 'timeDisplay2');
                updateSubtitles(2, video2.currentTime);
            });
            // Keep play/pause icons in sync with state, even on programmatic play/pause
            video1.addEventListener('play',   () => { const b = document.getElementById('playBtn1'); if (b) b.textContent = '⏸'; });
            video1.addEventListener('pause',  () => { const b = document.getElementById('playBtn1'); if (b) b.textContent = '▶';  });
            video2.addEventListener('play',   () => { const b = document.getElementById('playBtn2'); if (b) b.textContent = '⏸'; });
            video2.addEventListener('pause',  () => { const b = document.getElementById('playBtn2'); if (b) b.textContent = '▶';  });
            video1.addEventListener('timeupdate', handleSync);

            // Keyboard controls (includes transform hotkeys for MAIN player)
            document.addEventListener('keydown', handleKeyboard);

            // Dragging functionality
            initializeDragging();

            // Inactivity handling (hide controls and cursor)
            setupInactivityHide();

            // Ensure initial transform is applied
            applyTransform();
        }

        // Hide controls and cursor after 1s of no mouse movement
        function setupInactivityHide() {
            const IDLE_MS = 1000;
            let inactivityTimer = null;

            const root = document.body;

            const showControls = () => {
                root.classList.remove('idle');
            };

            const hideControls = () => {
                root.classList.add('idle');
            };

            const resetTimer = () => {
                showControls();
                if (inactivityTimer) clearTimeout(inactivityTimer);
                inactivityTimer = setTimeout(hideControls, IDLE_MS);
            };

            // Mouse/pointer movement resets the timer
            document.addEventListener('mousemove', resetTimer, { passive: true });
            document.addEventListener('pointermove', resetTimer, { passive: true });
            document.addEventListener('mousedown', resetTimer, { passive: true });
            document.addEventListener('touchstart', resetTimer, { passive: true });
            document.addEventListener('touchmove', resetTimer, { passive: true });

            // Start in non-idle state, then schedule initial hide
            resetTimer();
        }

        function loadVideo(event, video) {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                video.src = url;
                video.load();
            }
        }

        function togglePlay(video, btnId) {
            const btn = document.getElementById(btnId);
            if (video.paused) {
                video.play();
                btn.textContent = '⏸';
            } else {
                video.pause();
                btn.textContent = '▶';
            }
            
            // Sync play/pause if synced (works for both players)
            if (isSynced) {
                if (video === video1) {
                    if (video.paused) {
                        video2.pause();
                        document.getElementById('playBtn2').textContent = '▶';
                    } else {
                        video2.play();
                        document.getElementById('playBtn2').textContent = '⏸';
                    }
                } else if (video === video2) {
                    if (video.paused) {
                        video1.pause();
                        document.getElementById('playBtn1').textContent = '▶';
                    } else {
                        video1.play();
                        document.getElementById('playBtn1').textContent = '⏸';
                    }
                }
            }
        }

        function seekVideo(event, video, progressId) {
            const progressContainer = document.getElementById(progressId);
            const rect = progressContainer.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;
            const newTime = percentage * video.duration;
            
            video.currentTime = newTime;
            
            // Sync seeking if synced - but be more precise about timing
            if (isSynced && video === video1) {
                const syncedTime = newTime - syncPoint1 + syncPoint2 + delay;
                if (syncedTime >= 0 && syncedTime <= video2.duration) {
                    video2.currentTime = syncedTime;
                    lastSyncTime = Date.now(); // Update last sync time to prevent immediate re-sync
                }
            }
        }

        function changeSpeed(video, speed) {
            const rate = parseFloat(speed);
            video.playbackRate = rate;

            // Sync speed both ways when synced
            if (isSynced) {
                if (video === video1) {
                    video2.playbackRate = rate;
                    document.getElementById('speedSelect2').value = String(rate);
                } else if (video === video2) {
                    video1.playbackRate = rate;
                    document.getElementById('speedSelect1').value = String(rate);
                }
            }
        }

        function updateProgress(video, progressBarId, timeDisplayId) {
            const progressBar = document.getElementById(progressBarId);
            const timeDisplay = document.getElementById(timeDisplayId);
            
            if (video.duration) {
                const percentage = (video.currentTime / video.duration) * 100;
                progressBar.style.width = percentage + '%';
                
                const current = formatTime(video.currentTime);
                const total = formatTime(video.duration);
                timeDisplay.textContent = timeDisplayId.includes('2') ? current : `${current} / ${total}`;
            }
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function loadSubtitle(event, playerNum) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.srt')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const srtContent = e.target.result;
                    const parsedSubtitles = parseSRT(srtContent);
                    
                    if (playerNum === 1) {
                        subtitles1 = parsedSubtitles;
                    } else {
                        subtitles2 = parsedSubtitles;
                    }
                };
                reader.readAsText(file);
            }
        }

        function parseSRT(srtContent) {
            const subtitles = [];
            const blocks = srtContent.trim().split(/\n\s*\n/);
            
            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (lines.length >= 3) {
                    // Skip the sequence number (first line)
                    const timeString = lines[1];
                    // Get all lines after the timestamp as subtitle text
                    const text = lines.slice(2).join('\n').trim();
                    
                    // Parse time format: 00:00:20,000 --> 00:00:24,400
                    const timeMatch = timeString.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*--\>\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                    
                    if (timeMatch && text) {
                        const startTime = parseInt(timeMatch[1]) * 3600 + 
                                         parseInt(timeMatch[2]) * 60 + 
                                         parseInt(timeMatch[3]) + 
                                         parseInt(timeMatch[4]) / 1000;
                        
                        const endTime = parseInt(timeMatch[5]) * 3600 + 
                                       parseInt(timeMatch[6]) * 60 + 
                                       parseInt(timeMatch[7]) + 
                                       parseInt(timeMatch[8]) / 1000;
                        
                        subtitles.push({
                            start: startTime,
                            end: endTime,
                            text: text
                        });
                    }
                }
            });
            
            return subtitles;
        }

        function toggleSubtitles(playerNum) {
            if (playerNum === 1) {
                subtitlesEnabled1 = !subtitlesEnabled1;
                const btn = document.getElementById('subtitleBtn1');
                const display = document.getElementById('subtitle1Display');
                
                btn.style.background = subtitlesEnabled1 ? 'rgba(255,255,255,0.3)' : 'none';
                if (!subtitlesEnabled1) {
                    display.style.display = 'none';
                }
            } else {
                subtitlesEnabled2 = !subtitlesEnabled2;
                const btn = document.getElementById('subtitleBtn2');
                const display = document.getElementById('subtitle2Display');
                
                btn.style.background = subtitlesEnabled2 ? 'rgba(255,255,255,0.3)' : 'none';
                if (!subtitlesEnabled2) {
                    display.style.display = 'none';
                }
            }
        }

        function updateSubtitles(playerNum, currentTime) {
            const subtitles = playerNum === 1 ? subtitles1 : subtitles2;
            const enabled = playerNum === 1 ? subtitlesEnabled1 : subtitlesEnabled2;
            const displayId = playerNum === 1 ? 'subtitle1Display' : 'subtitle2Display';
            const display = document.getElementById(displayId);
            
            if (!enabled || subtitles.length === 0) {
                display.style.display = 'none';
                return;
            }
            
            // Find current subtitle
            const currentSubtitle = subtitles.find(subtitle => 
                currentTime >= subtitle.start && currentTime <= subtitle.end
            );
            
            if (currentSubtitle) {
                display.textContent = currentSubtitle.text;
                display.style.display = 'block';
            } else {
                display.style.display = 'none';
            }
        }

        function swapVideos() {
            // Store current states
            const video1Src = video1.src;
            const video2Src = video2.src;
            const video1CurrentTime = video1.currentTime;
            const video2CurrentTime = video2.currentTime;
            const video1Volume = video1.volume;
            const video2Volume = video2.volume;
            const video1Muted = video1.muted;
            const video2Muted = video2.muted;
            const video1PlaybackRate = video1.playbackRate;
            const video2PlaybackRate = video2.playbackRate;
            const video1Paused = video1.paused;
            const video2Paused = video2.paused;
            
            // Store subtitle states
            const tempSubtitles1 = [...subtitles1];
            const tempSubtitles2 = [...subtitles2];
            const tempSubtitlesEnabled1 = subtitlesEnabled1;
            const tempSubtitlesEnabled2 = subtitlesEnabled2;
            
            // Store sync points if they exist
            const tempSyncPoint1 = syncPoint1;
            const tempSyncPoint2 = syncPoint2;
            const wasSynced = isSynced;
            
            // Swap video sources
            video1.src = video2Src;
            video2.src = video1Src;
            
            // Wait for videos to load then restore states
            Promise.all([
                new Promise(resolve => {
                    if (video1Src) {
                        video1.addEventListener('loadeddata', resolve, { once: true });
                    } else {
                        resolve();
                    }
                }),
                new Promise(resolve => {
                    if (video2Src) {
                        video2.addEventListener('loadeddata', resolve, { once: true });
                    } else {
                        resolve();
                    }
                })
            ]).then(() => {
                // Restore states with swapped values
                if (video2Src) video1.currentTime = video2CurrentTime;
                if (video1Src) video2.currentTime = video1CurrentTime;
                
                video1.volume = video2Volume;
                video2.volume = video1Volume;
                video1.muted = video2Muted;
                video2.muted = video1Muted;
                video1.playbackRate = video2PlaybackRate;
                video2.playbackRate = video1PlaybackRate;
                
                // Update UI controls
                document.getElementById('volumeSlider1').value = video2Volume;
                document.getElementById('volumeSlider2').value = video1Volume;
                // Update visual fills after programmatic value changes
                const vs1 = document.getElementById('volumeSlider1');
                const vs2 = document.getElementById('volumeSlider2');
                if (vs1) vs1.style.setProperty('--vol', (video2Volume * 100) + '%');
                if (vs2) vs2.style.setProperty('--vol', (video1Volume * 100) + '%');
                document.getElementById('speedSelect1').value = video2PlaybackRate;
                document.getElementById('speedSelect2').value = video1PlaybackRate;
                
                // Update volume button icons
                changeVolume(video1, video1.volume, 'muteBtn1');
                changeVolume(video2, video2.volume, 'muteBtn2');
                
                // Swap subtitles
                subtitles1 = tempSubtitles2;
                subtitles2 = tempSubtitles1;
                subtitlesEnabled1 = tempSubtitlesEnabled2;
                subtitlesEnabled2 = tempSubtitlesEnabled1;
                
                // Update subtitle button states
                document.getElementById('subtitleBtn1').style.background = subtitlesEnabled1 ? 'rgba(255,255,255,0.3)' : 'none';
                document.getElementById('subtitleBtn2').style.background = subtitlesEnabled2 ? 'rgba(255,255,255,0.3)' : 'none';
                
                // Restore sync points with swapped values
                if (wasSynced) {
                    syncPoint1 = tempSyncPoint2; // Swap sync points
                    syncPoint2 = tempSyncPoint1;
                    isSynced = true;
                }
                
                // Restore play states
                if (!video2Paused && video1Src) {
                    video1.play();
                    document.getElementById('playBtn1').textContent = '⏸';
                } else {
                    document.getElementById('playBtn1').textContent = '▶';
                }
                
                if (!video1Paused && video2Src) {
                    video2.play();
                    document.getElementById('playBtn2').textContent = '⏸';
                } else {
                    document.getElementById('playBtn2').textContent = '▶';
                }

                // IMPORTANT: Keep transforms attached to MAIN player only.
                // Swapping videos does not move transforms to overlay; they always apply to #video1.
                applyTransform();
            });
        }

        function changeVolume(video, volume, muteBtnId) {
            video.volume = volume;
            const muteBtn = document.getElementById(muteBtnId);
            if (volume == 0) {
                muteBtn.textContent = '🔇';
            } else if (volume < 0.5) {
                muteBtn.textContent = '🔉';
            } else {
                muteBtn.textContent = '🔊';
            }
        }

        function toggleMute(video, muteBtnId, sliderId) {
            const muteBtn = document.getElementById(muteBtnId);
            const slider = document.getElementById(sliderId);
            
            if (video.muted) {
                video.muted = false;
                video.volume = slider.value;
                changeVolume(video, slider.value, muteBtnId);
                if (slider) slider.style.setProperty('--vol', (parseFloat(slider.value) * 100) + '%');
            } else {
                video.muted = true;
                muteBtn.textContent = '🔇';
            }
        }

        function setSyncPoint() {
            if (video1.duration && video2.duration) {
                syncPoint1 = video1.currentTime;
                syncPoint2 = video2.currentTime;
                isSynced = true;
                
                // Start video2 from its sync point when video1 plays
                video2.currentTime = syncPoint2;
                
                // Ensure both players are playing
                if (video1.paused) {
                    video1.play();
                    const pb1 = document.getElementById('playBtn1');
                    if (pb1) pb1.textContent = '⏸';
                }
                // Always start video2
                video2.play();
                const pb2 = document.getElementById('playBtn2');
                if (pb2) pb2.textContent = '⏸';

                // (sync status UI removed)
                
                // Hide sync controls after setting sync point
                document.getElementById('syncControls').style.display = 'none';
            }
        }

        // (Clear Sync and Delay controls removed)

        let lastSyncTime = 0;
        const SYNC_THRESHOLD = 0.5; // Only sync if difference is more than 0.5 seconds
        const SYNC_INTERVAL = 100; // Minimum time between sync adjustments (ms)

        function handleSync() {
            if (isSynced && !video1.paused) {
                const now = Date.now();
                const targetTime = (video1.currentTime - syncPoint1) + syncPoint2 + delay;
                const timeDifference = Math.abs(video2.currentTime - targetTime);
                
                // Only sync if there's a significant difference and enough time has passed
                if (targetTime >= 0 && 
                    timeDifference > SYNC_THRESHOLD && 
                    now - lastSyncTime > SYNC_INTERVAL) {
                    
                    video2.currentTime = targetTime;
                    lastSyncTime = now;
                }
            }
        }

        // ================== Keyboard ==================
        function handleKeyboard(event) {
            const tag = event.target.tagName;
            if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;

            // Space & arrows (existing behavior)
            if (event.key === ' ') {
                event.preventDefault();
                togglePlay(video1, 'playBtn1');
                return;
            }
            if (event.key === 'ArrowLeft') {
                event.preventDefault();
                skipTime(-5);
                return;
            }
            if (event.key === 'ArrowRight') {
                event.preventDefault();
                skipTime(5);
                return;
            }

            // Numpad transform/move hotkeys for MAIN player only
            const code = event.code;
            const alt = event.altKey;
            const ctrl = event.ctrlKey;

            switch(code) {
                // === Zoom / Rotate90 / Move Up-Right ===
                case 'Numpad9':
                    if (alt) { // Rotate ⭮ 90° (clockwise)
                        tf.rot += 90; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Up-Right
                        tf.tx += MOVE_STEP; tf.ty -= MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Zoom In
                        tf.zoom = clamp(tf.zoom + ZOOM_STEP, MIN_ZOOM, MAX_ZOOM); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Zoom Out / Rotate ⭯ / Move Down-Left ===
                case 'Numpad1':
                    if (alt) { // Rotate ⭯ (counterclockwise) small step
                        tf.rot -= ROTATE_STEP; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Down-Left
                        tf.tx -= MOVE_STEP; tf.ty += MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Zoom Out
                        tf.zoom = clamp(tf.zoom - ZOOM_STEP, MIN_ZOOM, MAX_ZOOM); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Horizontal Stretch / Flip H / Move Right ===
                case 'Numpad6':
                    if (alt) { // Flip Horizontally (toggle)
                        tf.flipX *= -1; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Right
                        tf.tx += MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Stretch X
                        tf.stretchX = clamp(tf.stretchX + STRETCH_STEP, MIN_STRETCH, MAX_STRETCH); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Horizontal Compress / Flip H / Move Left ===
                case 'Numpad4':
                    if (alt) { // Flip Horizontally (toggle)
                        tf.flipX *= -1; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Left
                        tf.tx -= MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Compress X
                        tf.stretchX = clamp(tf.stretchX - STRETCH_STEP, MIN_STRETCH, MAX_STRETCH); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Vertical Stretch / Flip V / Move Up ===
                case 'Numpad8':
                    if (alt) { // Flip Vertically (toggle)
                        tf.flipY *= -1; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Up
                        tf.ty -= MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Stretch Y
                        tf.stretchY = clamp(tf.stretchY + STRETCH_STEP, MIN_STRETCH, MAX_STRETCH); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Vertical Compress / Flip V / Move Down ===
                case 'Numpad2':
                    if (alt) { // Flip Vertically (toggle)
                        tf.flipY *= -1; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Down
                        tf.ty += MOVE_STEP; applyTransform(); event.preventDefault();
                    } else { // Compress Y
                        tf.stretchY = clamp(tf.stretchY - STRETCH_STEP, MIN_STRETCH, MAX_STRETCH); applyTransform(); event.preventDefault();
                    }
                    break;
                // === Rotate ⭮ (clockwise small) / Move Down-Right ===
                case 'Numpad3':
                    if (alt) { // Rotate ⭮
                        tf.rot += ROTATE_STEP; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Down-Right
                        tf.tx += MOVE_STEP; tf.ty += MOVE_STEP; applyTransform(); event.preventDefault();
                    }
                    break;
                // === Rotate ⭯ 90° (counterclockwise) / Move Up-Left ===
                case 'Numpad7':
                    if (alt) { // Rotate ⭯ 90°
                        tf.rot -= 90; applyTransform(); event.preventDefault();
                    } else if (ctrl) { // Move Up-Left
                        tf.tx -= MOVE_STEP; tf.ty -= MOVE_STEP; applyTransform(); event.preventDefault();
                    }
                    break;
                // === Recenter / Reset ===
                case 'Numpad5':
                    if (ctrl) { // Recenter (only translate)
                        recenter(); event.preventDefault();
                    } else { // Reset all transformations
                        resetTransforms(); event.preventDefault();
                    }
                    break;
                default:
                    // no-op
                    break;
            }
        }

        function skipTime(seconds) {
            const newTime = Math.max(0, Math.min(video1.duration || 0, (video1.currentTime || 0) + seconds));
            video1.currentTime = newTime;
            
            if (isSynced) {
                const syncedTime = newTime - syncPoint1 + syncPoint2 + delay;
                if (syncedTime >= 0 && syncedTime <= (video2.duration || 0)) {
                    video2.currentTime = syncedTime;
                    lastSyncTime = Date.now(); // Update last sync time to prevent immediate re-sync
                }
            }
        }

        function initializeDragging() {
            const overlay = document.getElementById('overlayPlayer');

            overlay.addEventListener('mousedown', startDrag);
            // Corner resize handles
            overlay.querySelectorAll('.resize-handle').forEach(h => {
                h.addEventListener('mousedown', startResize);
            });

            function startDrag(e) {
                // Don't start drag if clicking on controls or resize handle
                if (e.target.closest('.overlay-controls') || e.target.closest('.resize-handle')) return;
                
                // Check if clicking near the resize handle (bottom-right corner)
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const isNearResizeHandle = x > rect.width - 20 && y > rect.height - 20;
                
                if (isNearResizeHandle) return;
                
                isDragging = true;
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                document.body.classList.add('dragging');
                
                // Temporarily disable resize while dragging
                overlay.style.resize = 'none';
            }

            function drag(e) {
                if (!isDragging) return;
                
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                overlay.style.left = Math.max(0, Math.min(window.innerWidth - overlay.offsetWidth, x)) + 'px';
                overlay.style.top = Math.max(0, Math.min(window.innerHeight - overlay.offsetHeight, y)) + 'px';
                overlay.style.right = 'auto';
            }

            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.body.classList.remove('dragging');
                    
                    // Re-enable resize after dragging
                    overlay.style.resize = 'none';
                }
            }

            function startResize(e) {
                e.preventDefault();
                e.stopPropagation();
                const rect = overlay.getBoundingClientRect();
                isResizing = true;
                resizeState.startX = e.clientX;
                resizeState.startY = e.clientY;
                resizeState.startW = rect.width;
                resizeState.startH = rect.height;
                resizeState.startLeft = rect.left;
                resizeState.startTop = rect.top;
                resizeState.handle = e.target.getAttribute('data-handle');

                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopResize);
                document.body.classList.add('dragging');
            }

            function doResize(e) {
                if (!isResizing) return;
                const dx = e.clientX - resizeState.startX;
                const dy = e.clientY - resizeState.startY;

                // Compute new geometry based on handle
                let newW = resizeState.startW;
                let newH = resizeState.startH;
                let newLeft = resizeState.startLeft;
                let newTop = resizeState.startTop;

                const handle = resizeState.handle;
                if (handle === 'se') {
                    newW = resizeState.startW + dx;
                    newH = resizeState.startH + dy;
                } else if (handle === 'sw') {
                    newW = resizeState.startW - dx;
                    newH = resizeState.startH + dy;
                    newLeft = resizeState.startLeft + dx;
                } else if (handle === 'ne') {
                    newW = resizeState.startW + dx;
                    newH = resizeState.startH - dy;
                    newTop = resizeState.startTop + dy;
                } else if (handle === 'nw') {
                    newW = resizeState.startW - dx;
                    newH = resizeState.startH - dy;
                    newLeft = resizeState.startLeft + dx;
                    newTop = resizeState.startTop + dy;
                }

                // Enforce minimums
                const cs = window.getComputedStyle(overlay);
                const minW = parseFloat(cs.minWidth) || 200;
                const minH = parseFloat(cs.minHeight) || 112;

                if (newW < minW) {
                    if (handle === 'sw' || handle === 'nw') {
                        newLeft += (newW - minW);
                    }
                    newW = minW;
                }
                if (newH < minH) {
                    if (handle === 'nw' || handle === 'ne') {
                        newTop += (newH - minH);
                    }
                    newH = minH;
                }

                // Keep within viewport (optional soft clamp)
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - newW));
                newTop = Math.max(0, Math.min(newTop, window.innerHeight - newH));

                overlay.style.width = newW + 'px';
                overlay.style.height = newH + 'px';
                overlay.style.left = newLeft + 'px';
                overlay.style.top = newTop + 'px';
                overlay.style.right = 'auto';
            }

            function stopResize() {
                if (!isResizing) return;
                isResizing = false;
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', stopResize);
                document.body.classList.remove('dragging');
            }
        }

        function toggleOverlay() {
            const overlay = document.getElementById('overlayPlayer');
            overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', initializePlayers);
    </script>
</body>
</html>
